学习目标:
1 讲解ASN.1报文编解码函数
2 编写代码测试报文编解码函数
3 将底层的报文编解码函数封装成类
  类图介绍
4 如何在VS中创建linux项目

1 客户端与服务端需要交换数据:
  sockt API编程:
  int socket(int domain, int type, int protocol);
  int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
  int bind(int sockfd, struct sockaddr *my_addr, socklen_t addrlen);
  int listen(int s, int backlog);
  int accept(int s, struct sockaddr *addr, socklen_t *addrlen);
  ssize_t read(int fd, void *buf, size_t count);
  ssize_t recv(int sockfd, void *buf, size_t len, int flags);
  ssize_t write(int fd, const void *buf, size_t count);
  int send(int s, const void *msg, size_t len, int flags);
  
2 两台机器通信
  1 两台机器的操作系统平台不同:
  	一台是32为windows, 一台是linux 64系统
  2 网络传输的时候用的是大端模式
  	只要是传输的数据的数据类型超过了一个字节都需要进行网络字节序的转换
  	关于字节序序的函数:
  		htons htonl ntohs ntohl 
	  		h: host
	  		to: 到
	  		n: network
	  		l: long
	  		s: short
	  假如在从A传递数据给B, 需要传递一个结构体
  3 字节序对齐不一样
     struct test
     {
     	int a;
     	char c;
     	double d;
     }
  4 两台服务的开发语言不同
  	对于C语言, 一个字符占用一个字节
  	对于java, 一个字符占用2个字节
  	
 报文: 其实就是数据.
上述几种情况, 涉及到网络数据传输, 都需要对数据进行编解码操作.

UML类图:
继承关系:
	使用带有空心箭头的实线来表示, 箭头指向的是父类.
	
public:继承
父类:   public   procected   private   
子类  public   procected   private  
public: 
      public   procected  private
protected:
	  protected  protected  private
private:
	  都不可以访问

如果没有继承, 在类内部没有任何限制, 可以相互访问;
如果没有继承, 在类的外部, 只有public的可以对外部开放, private和protected
都不可以访问.

若有继承关系:
	对于private继承来说, private成员子类都不可以访问;
	对于protected继承来说, protected成员可以被子类访问;
	抽象继承在类图中表现为斜体;

单向关联关系:
	使用带有箭头的实线表示, 箭头指向类的成员对象.
双向关联关系:
	使用带有双向箭头的实线来表示, 两个类相互包含
	
自关联:
	最常见的就是链表操作, 箭头执行类自己.

聚合关系:
	使用带有空心菱形的带箭头的实线来表示, 空心的菱形在聚合类一侧, 箭头指向成员对象
组合关系:
	使用带有实心菱形的带箭头的实线来表示, 实心的菱形在组合类一侧, 箭头指向成员对象
	
聚合和组合:
	都是整体和部分的关系.

依赖关系: 类中的成员函数的参数用到了某个类的对象
	使用带有箭头的虚线表示, 箭头指向被依赖的类.

name:xiaowu
name6xiaowu

ITCAST_INT DER_ItAsn1_WriteInteger(ITCAST_UINT32 integer, ITASN1_INTEGER **ppDerInteger);
函数说明:对整形数据进行编码操作
函数参数:
	integer: 输入参数, 表示待编码的整形数据
	ppDerInteger: 传输参数, 编码之后的数据
返回值:
	成功或者失败
	
ITCAST_INT DER_ItAsn1_ReadInteger(ITASN1_INTEGER *pDerInteger, ITCAST_UINT32 *pInteger);
函数说明: 对整形数据解码
参数说明: 
	pDerInteger: 传入参数, 表示待解码的数据
	pInteger: 传出参数, 表示解码之后的数据
返回值:
	成功或者失败
	  ITCAST_ANYBUF p;
	  ITCAST_UINT32 aa; 
例如: DER_ItAsn1_ReadInteger(&p, &aa);

ITCAST_INT DER_ItAsn1_WritePrintableString(ITASN1_PRINTABLESTRING *pPrintString, ITASN1_PRINTABLESTRING **ppDerPrintString);
函数说明:编码字符串数据
函数参数:
	pPrintString: 输入参数, 表示要编码的数据
	ppDerPrintString: 输出参数, 表示编码之后的数据
返回值:
	成功或者失败	
	
ITCAST_INT DER_ItAsn1_ReadPrintableString(ITASN1_PRINTABLESTRING *pDerPrintString, ITASN1_PRINTABLESTRING **ppPrintString);
函数说明: 解码函数, 将ANYCAST_ANYBUF类型解码到第二个参数
参数说明:
		pDerPrintString: 输入参数, 表示待解码的数据
		ppPrintString: 输出参数, 存放解码之后的数据
返回值:
	成功或者失败
	
ITCAST_INT DER_ITCAST_String_To_AnyBuf(ITCAST_ANYBUF **pOriginBuf, unsigned char * strOrigin, int strOriginLen);
函数说明: 将char *---->ITCAST_ANYBUF类型
函数参数:
	pOriginBuf: 传出参数, ITCAST_ANYBUF指针
	strOrigin: 传入参数, 待转换的字符串
	strOriginLen: 传入参数, strOrigin的字符串长度
返回值:
	成功或者失败

int EncodeChar(char *pData, int dataLen, ITCAST_ANYBUF **outBuf);
函数说明: 将char *类型数据进行编码
函数参数:
	pData: 输入参数, 指的是待编码的字符串
	dataLen: 输入参数, 指的是pData的长度
	outBuf: 输出参数, ITCAST_ANYBUF类型的数据, TLV格式
	
int DecodeChar(ITCAST_ANYBUF *inBuf, char **Data, int *pDataLen);

ITCAST_INT DER_ItAsn1_WriteSequence(ITASN1_SEQUENCE *pSequence, ITCAST_ANYBUF **ppDerSequence);
函数说明: 序列化链表, 将链表序列化成字节流数据
函数参数:
	pSequence: 输入参数, 待序列化的数据
	ppDerSequence: 输出参数, 序列化之后的数据

ITCAST_INT DER_ItAsn1_ReadSequence(ITCAST_ANYBUF *pDerSequence, ITASN1_SEQUENCE **ppSequence);
函数说明: 反序列化
参数说明:
	pDerSequence:输入参数, 开始需要将char *--->ITCAST_ANYBUF类型
	ppSequence: 输出参数, 获得链表头节点

ITCAST_INT DER_ITCAST_FreeQueue(ITCAST_ANYBUF *pAnyBuf);
释放内存

int fun(char **p)
{
	*p = malloc();
}

int main()
{
	char name[10];
	fun(&name);
}

使用链表:
1 错误的方法:
    pNode = NULL;
	head->next = pNode;
	pNode = malloc();
2 正确的用法
  pNode = malloc();
  head->next = pNode;
	